module Framework.V2.Translation.NChoice-to-2Choice {‚Ñì‚ÇÅ} {Q : Set ‚Ñì‚ÇÅ} where

open import Data.Bool using (Bool; false; true; if_then_else_)
open import Data.List using (List; _‚à∑_; []; map)
open import Data.List.NonEmpty using (List‚Å∫; _‚à∑_)
open import Data.Nat using (‚Ñï; suc; zero)

open import Relation.Binary.PropositionalEquality as Eq using (_‚â°_; _‚âó_; refl)

import Data.IndexedSet
open import Util.List using (find-or-last)

open import Relation.Binary using (Setoid; IsEquivalence)

open import Framework.V2.Definitions using (ùîΩ)
open import Framework.V2.Compiler using (ConstructCompiler)
open import Framework.V2.Constructs.Choices as Chc
open Chc.Choice‚ÇÇ using (_‚ü®_,_‚ü©) renaming (Syntax to 2Choice; Standard-Semantics to ‚ü¶_‚üß‚ÇÇ; Config to Config‚ÇÇ)
open Chc.Choice‚Çô using (_‚ü®_‚ü©) renaming (Syntax to NChoice; Standard-Semantics to ‚ü¶_‚üß‚Çô; Config to Config‚Çô)
open Chc.VLChoice‚ÇÇ using () renaming (Construct to C‚ÇÇ)
open Chc.VLChoice‚Çô using () renaming (Construct to C‚Çô)

record IndexedDimension {‚Ñì} (Q : Set ‚Ñì) : Set ‚Ñì where
  constructor _‚àô_
  field
    dim : Q
    index : ‚Ñï

private
  I = IndexedDimension Q
  NConfig = Config‚Çô Q
  2Config = Config‚ÇÇ I

open Data.Nat using (_<_; _‚â§_; s‚â§s; z‚â§n)
record ConfSpec (D : Q) (conf : NConfig ‚Üí 2Config) : Set ‚Ñì‚ÇÅ where
  field
    {-|
    A translated, binary configuration (conf c)
    has to pick the same alternative as the original configuration c.
    This alternative is nested in the binary term.
    The nesting depth is exactly equal to the alternative index:
    - the first alternative (0) is the left alternative of the root choice at level 0
    - the second alternative (1) is the left alternative of the choice (1) in the right alternative of the root choice 0
    - and so on.
    Hence the translated, binary configuration (conf c)
    has to pick the left alternative (true)
    in the choice at nesting level (c D).
    -}
    select-n : ‚àÄ (c : NConfig) {i : ‚Ñï}
      ‚Üí i ‚â° c D
      ‚Üí (conf c) (D ‚àô i) ‚â° true

    {-|
    All alternatives before the desired alternative must be deselected so
    that we go right until we find the correct alternative to pick.
    -}
    deselect-<n : ‚àÄ (c : NConfig) {i : ‚Ñï}
      ‚Üí i < c D
      ‚Üí (conf c) (D ‚àô i) ‚â° false

    {-|
    There is no third requirement because we do not care
    for the values of the translated configuration for dimensions
    deeper than (c D).
    These alternatives will never be reached upon configuration.
    -}
open ConfSpec

record FnocSpec (n : ‚Ñï) (fnoc : 2Config ‚Üí NConfig) : Set ‚Ñì‚ÇÅ where
  field
    {-|
    The nary config must chose index i iff
    - the alternative at nesting depth i is chosen in the binary expression
    - and no other alternative at a higher nesting depth was chosen.
    -}
    correct : ‚àÄ (c : 2Config) (D : Q) (i : ‚Ñï)
      ‚Üí c (D ‚àô i) ‚â° true
      ‚Üí (‚àÄ (j : ‚Ñï) ‚Üí j < i ‚Üí c (D ‚àô j) ‚â° false)
      ‚Üí (fnoc c) D ‚â° i
open FnocSpec

module Translate (Carrier : Set ‚Ñì‚ÇÅ) where --{‚Ñì‚ÇÇ} (S : Setoid ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ) where
  -- TODO: Generalize everything here to setoid.
  -- open Setoid S
  -- module ‚âà-Eq = IsEquivalence isEquivalence
  -- Carrier = Setoid.Carrier S
  _‚âà_ = _‚â°_
  open Eq.‚â°-Reasoning

  open Data.Nat using (_‚à∏_; _‚â§_)
  open import Data.Nat.Show using (show)

    -- L‚ÇÇ-has-choices-syntactically : BinaryChoice I ‚àà‚Çõ L‚ÇÇ
    -- L‚ÇÇ-has-choices-syntactically = make L‚ÇÇ-has-choices

    -- mkChoice : BinaryChoice I L‚ÇÇ A ‚Üí L‚ÇÇ A
    -- mkChoice = cons L‚ÇÇ-has-choices-syntactically

    -- mkChoice-preserves : ‚àÄ (c : BinaryChoice I L‚ÇÇ A) ‚Üí ‚ü¶ mkChoice c ‚üß‚ÇÇ ‚âó BinaryChoice-Semantics VL‚ÇÇ c
    -- mkChoice-preserves = preservation L‚ÇÇ-has-choices

  open import Data.Vec using (Vec; []; _‚à∑_; fromList)

  data Intermediate : Set ‚Ñì‚ÇÅ where
    val : Carrier                ‚Üí Intermediate
    chc : 2Choice I Intermediate ‚Üí Intermediate

  {-# TERMINATING #-}
  ‚ü¶_‚üß·µ¢ : Intermediate ‚Üí 2Config ‚Üí Carrier
  ‚ü¶ val v ‚üß·µ¢ _ = v
  ‚ü¶ chc Œ≥ ‚üß·µ¢ c = ‚ü¶ ‚ü¶ Œ≥ ‚üß‚ÇÇ c ‚üß·µ¢ c
  -- TODO: Write eliminator for Intermediate given a variability language with choices.
  --       Then prove that the eliminator preserves semantics.

  unroll : ‚àÄ {n}
    ‚Üí (max : ‚Ñï)
    ‚Üí Q      -- initial dimension in input formula that we translate (D in the example above).
    ‚Üí Vec Carrier (suc n) -- remaining alternatives of the choice to unroll. We let this shrink recursively.
    ‚Üí 2Choice I Intermediate
  unroll {n} max D (e ‚à∑ [])     = (D ‚àô (max ‚à∏ n)) ‚ü® val e , val e ‚ü©
  unroll {n} max D (l ‚à∑ r ‚à∑ es) = (D ‚àô (max ‚à∏ n)) ‚ü® val l , chc (unroll max D (r ‚à∑ es)) ‚ü©
  -- an unrolled choice D ‚àô i gives you i effective choices

  convert : NChoice Q Carrier ‚Üí 2Choice I Intermediate
  convert (D ‚ü® e ‚à∑ es ‚ü©) = unroll #es D (e ‚à∑ fromList es)
    where #es = Data.List.length es

  -- unroll-name : ‚àÄ (D : F) (e : L‚ÇÅ A) (es : List (L‚ÇÅ A)) (n : ‚Ñï)
    -- ‚Üí Œ£[ x ‚àà L‚ÇÇ A ] (unroll D (e ‚à∑ es) n ‚â° (D ‚àô n) ‚ü® t e , x ‚ü©)
  -- unroll-name D e [] n = t e and refl
  -- unroll-name D e (r ‚à∑ rs) n = mkChoice (unroll D (r ‚à∑ rs) (suc n)) and refl

  module Preservation
    (confi : NConfig ‚Üí 2Config)
    (fnoci : 2Config ‚Üí NConfig)
    (D : Q)
    where
    open Data.List using (length)
    open import Data.Product using () renaming (_,_ to _and_)
    -- open import Data.List.Relation.Unary.All using (All; []; _‚à∑_)
    -- open import Data.List.NonEmpty.Relation.Unary.All using (_‚à∑_) renaming (All to All‚Å∫)
    module ISS = Data.IndexedSet (Eq.setoid Carrier)
    -- module ISS = Data.IndexedSet S
    open ISS using (_‚àà_at_; _‚äÜ[_]_; _‚âÖ[_][_]_)
    open ISS.‚âÖ[]-Reasoning
    open import Util.AuxProofs using (if-idemp)
    open Eq.‚â°-Reasoning
    -- open Data.Nat using (_+_)
    -- open import Data.Nat.Properties using (‚â§-refl; m‚à∏n‚â§m; m‚à∏n‚â¢0‚áín<m; 0‚à∏n‚â°0; n‚à∏n‚â°0; m‚â§n‚áím‚à∏n‚â°0)

    preservation-‚äÜ : ‚àÄ (es : List‚Å∫ Carrier)
      ‚Üí ‚ü¶ D ‚ü® es ‚ü© ‚üß‚Çô ‚äÜ[ confi ] ‚ü¶ chc (convert (D ‚ü® es ‚ü©)) ‚üß·µ¢
    preservation-‚äÜ (head ‚à∑ []) c =
      Eq.cong
        (Œª eq ‚Üí ‚ü¶ eq ‚üß·µ¢ (confi c))
        (Eq.sym
          (if-idemp (confi c (D ‚àô 0))))
    preservation-‚äÜ (head ‚à∑ x ‚à∑ tail) c = {!!}

    preservation-‚äá : ‚àÄ (es : List‚Å∫ Carrier)
      ‚Üí ‚ü¶ chc (convert (D ‚ü® es ‚ü©)) ‚üß·µ¢ ‚äÜ[ fnoci ] ‚ü¶ D ‚ü® es ‚ü© ‚üß‚Çô
    preservation-‚äá es c = {!!}

    preservation : ‚àÄ (es : List‚Å∫ Carrier)
      ‚Üí ‚ü¶ D ‚ü® es ‚ü© ‚üß‚Çô ‚âÖ[ confi ][ fnoci ] ‚ü¶ chc (convert (D ‚ü® es ‚ü©)) ‚üß·µ¢
    preservation es = (preservation-‚äÜ es) and preservation-‚äá es
    --   ‚âÖ[]-begin
    --     ‚ü¶ D ‚ü® head ‚à∑ [] ‚ü© ‚üß‚Çô
    --   ‚âÖ[]‚ü®‚ü©
    --     (Œª c ‚Üí head)
    --   ‚âÖ[]‚ü® (Œª _ ‚Üí refl) and (Œª _ ‚Üí refl) ‚ü©
    --     (Œª c ‚Üí ‚ü¶ val head ‚üß·µ¢ c)
    --   ‚âêÀò[ c ]‚ü® Eq.cong (Œª eq ‚Üí ‚ü¶ eq ‚üß·µ¢ c) (if-idemp (c (D ‚àô 0))) ‚ü©
    --     (Œª c ‚Üí ‚ü¶ if c (D ‚àô 0) then val head else val head ‚üß·µ¢ c)
    --   ‚âÖ[]‚ü®‚ü©
    --     (Œª c ‚Üí ‚ü¶ ‚ü¶ (D ‚àô 0) ‚ü® val head , val head ‚ü© ‚üß‚ÇÇ c ‚üß·µ¢ c)
    --   ‚âÖ[]‚ü®‚ü©
    --     (Œª c ‚Üí ‚ü¶ ‚ü¶ convert (D ‚ü® head ‚à∑ [] ‚ü©) ‚üß‚ÇÇ c ‚üß·µ¢ c)
    --   ‚âÖ[]‚ü®‚ü©
    --     ‚ü¶ chc (convert (D ‚ü® head ‚à∑ [] ‚ü©)) ‚üß·µ¢
    --   ‚âÖ[]-‚àé
      -- ‚âÖ[]-begin
      --   ‚ü¶ D ‚ü® es ‚ü© ‚üß‚Çô
      -- ‚âÖ[]‚ü® {!!} ‚ü©
      --   ‚ü¶ chc (convert (D ‚ü® es ‚ü©)) ‚üß·µ¢
      -- ‚âÖ[]-‚àé

    -- -- convert-preserves-l : ‚àÄ (e : L‚ÇÅ A) (es : List (L‚ÇÅ A)) (c : NConfig)
    -- --   ‚Üí ConfSpec D confi
    -- --   -- ‚Üí ConfSpec D (length es) confi
    -- --   ‚Üí All‚Å∫ (Œª e ‚Üí ‚ü¶ e ‚üß‚ÇÅ c ‚â° ‚ü¶ t e ‚üß‚ÇÇ (confi c)) (e ‚à∑ es)
    -- --   ‚Üí   Choice-Semantics       VL‚ÇÅ (D ‚ü® e ‚à∑ es ‚ü©) c
    -- --     ‚â° BinaryChoice-Semantics VL‚ÇÇ (convert (D ‚ü® e ‚à∑ es ‚ü©)) (confi c)
    -- convert-preserves-l : ‚àÄ (e : Carrier) (es : List Carrier) (c : NConfig)
    --   ‚Üí ConfSpec D confi
    --   ‚Üí (max : ‚Ñï)
    --   ‚Üí (i : ‚Ñï)
    --   -- ‚Üí i + length es ‚â° max
    --   ‚Üí length es ‚â§ max
    --   ‚Üí max ‚â§ i + length es
    --   -- ‚Üí max ‚à∏ length es ‚â§ i
    --   ‚Üí c D ‚â° i
    --   ‚Üí   ‚ü¶ find-or-last (i ‚à∏ (max ‚à∏ length es)) (e ‚à∑ es) ‚üß‚Çô c
    --     ‚âà ‚ü¶ unroll max D (e ‚à∑ fromList es) ‚üß‚ÇÇ (confi c)
    --     -- ‚â° BinaryChoice-Semantics VL‚ÇÇ (unroll (length es) D (e ‚à∑ fromList es)) (confi c)

    -- convert-preserves-l-base : ‚àÄ (e : Carrier) (c : NConfig)
    --   ‚Üí   ‚ü¶ D ‚ü® e ‚à∑ [] ‚ü© ‚üß‚Çô c
    --     ‚â° ‚ü¶ convert (D ‚ü® e ‚à∑ [] ‚ü©) ‚üß‚ÇÇ (confi c)
    -- convert-preserves-l-base e c =
    --   begin
    --     ‚ü¶ D ‚ü® e ‚à∑ [] ‚ü© ‚üß‚Çô c
    --   ‚â°‚ü®‚ü©
    --     ‚ü¶ e ‚üß‚Çô c
    --   ‚â°‚ü®‚ü©
    --     ‚ü¶ e ‚üß‚ÇÇ (confi c)
    --   ‚â°‚ü® Eq.cong
    --        (Œª eq ‚Üí ‚ü¶ eq ‚üß‚ÇÇ (confi c))
    --        (Eq.sym
    --          (if-idemp ((confi c) (D ‚àô 0)))) ‚ü©
    --     ‚ü¶ if ((confi c) (D ‚àô 0)) then e else e ‚üß‚ÇÇ (confi c)
    --   ‚â°‚ü®‚ü©
    --     ‚ü¶ convert (D ‚ü® e ‚à∑ [] ‚ü©) ‚üß‚ÇÇ (confi c)
    --   ‚àé

    -- convert-preserves-l-base' : ‚àÄ (e : Carrier) (c : NConfig)
    --   ‚Üí (max : ‚Ñï)
    --   ‚Üí   ‚ü¶ D ‚ü® e ‚à∑ [] ‚ü© ‚üß‚Çô c
    --     ‚â° ‚ü¶ unroll max D (e ‚à∑ []) ‚üß‚ÇÇ (confi c)
    -- convert-preserves-l-base' e c max =
    --   begin
    --     ‚ü¶ D ‚ü® e ‚à∑ [] ‚ü© ‚üß‚Çô c
    --   ‚â°‚ü®‚ü©
    --     e
    --   ‚â°Àò‚ü® if-idemp ((confi c) (D ‚àô max)) ‚ü©
    --     (if ((confi c) (D ‚àô max)) then e else e)
    --   ‚â°‚ü®‚ü©
    --     ‚ü¶ unroll max D (e ‚à∑ []) ‚üß‚ÇÇ (confi c)
    --   ‚àé

    -- convert-preserves-l-step : ‚àÄ (l r : Carrier) (es : List Carrier) (c : NConfig)
    --    ‚Üí (conv : ConfSpec D confi)
    --    -- ‚Üí ConfSpec D (suc (length es)) confi
    --    ‚Üí (max : ‚Ñï)
    --    -- ‚Üí length (r ‚à∑ es) ‚â§ max
    --    ‚Üí (i : ‚Ñï)
    --    -- ‚Üí max ‚â§ i + length (r ‚à∑ es)
    --    ‚Üí (n‚â§max : length (r ‚à∑ es) ‚â§ max)
    --    ‚Üí (max‚â§i+n : max ‚â§ i + length (r ‚à∑ es))
    --    ‚Üí (cD‚â°i : c D ‚â° i)
    --    -- ‚Üí   Choice-Semantics VL‚ÇÅ (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©) c
    --    ‚Üí   ‚ü¶ find-or-last (i ‚à∏ (max ‚à∏ length (r ‚à∑ es))) (l ‚à∑ r ‚à∑ es) ‚üß‚Çô c
    --      -- ‚â° BinaryChoice-Semantics VL‚ÇÇ (convert (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©)) (confi c)
    --      ‚â° ‚ü¶ unroll max D (l ‚à∑ fromList (r ‚à∑ es)) ‚üß‚ÇÇ (confi c)
    -- convert-preserves-l-step l r es c conv (suc max) zero (s‚â§s n‚â§max) (s‚â§s max‚â§i+n) cD‚â°i = ?
    --   -- begin
    --   --   (find-or-last (zero ‚à∏ (max ‚à∏ n)) (l ‚à∑ r ‚à∑ es))
    --   -- ‚â°‚ü® 0‚à∏n‚â°0 (max ‚à∏ n) ‚ü©
    --   --   l
    --   -- ‚â°Àò‚ü® select-n conv c max‚à∏n‚â°cD ‚ü©
    --   --   (if (confi c) (D ‚àô (max ‚à∏ n)) then l else tail)
    --   -- ‚àé
    --   where n = length es
    --         tail = unroll (suc max) D (r ‚à∑ fromList es)

    --         max‚à∏n‚â°0 : max ‚à∏ n ‚â° 0
    --         max‚à∏n‚â°0 = m‚â§n‚áím‚à∏n‚â°0 max‚â§i+n

    --         max‚à∏n‚â°cD : max ‚à∏ n ‚â° c D
    --         max‚à∏n‚â°cD = Eq.trans max‚à∏n‚â°0 (Eq.sym cD‚â°i)
    -- convert-preserves-l-step l r es c conv (suc max) (suc i) (s‚â§s n‚â§max) (s‚â§s max‚â§i+n) cD‚â°i with max ‚à∏ (length es) in eq
    -- ... | zero = ?
    --   -- begin
    --   --   ‚ü¶ find-or-last i (r ‚à∑ es) ‚üß‚Çô c
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ find-or-last x (r ‚à∑ es) ‚üß‚Çô c)
    --   --      lh ‚ü©
    --   --   -- ‚ü¶ find-or-last (i ‚à∏ (max ‚à∏ length es)) (r ‚à∑ es) ‚üß‚Çô c
    --   --   ‚ü¶ find-or-last (suc i ‚à∏ (suc max ‚à∏ n)) (r ‚à∑ es) ‚üß‚Çô c
    --   -- -- ‚â°‚ü® {!!} ‚ü©
    --   -- ‚â°‚ü® convert-preserves-l r es c conv (r‚â°tr ‚à∑ es‚â°tes) (suc max) (suc i) n‚â§1+m 1+m‚â§1+i+n cD‚â°i ‚ü©
    --   -- -- ‚â°‚ü® convert-preserves-l r es c conv (r‚â°tr ‚à∑ es‚â°tes) (suc max) (suc i) ? cD‚â°i ‚ü©
    --   --   ‚ü¶ unroll (suc max) D (r ‚à∑ fromList es) ‚üß‚ÇÇ (confi c)
    --   -- ‚â°‚ü®‚ü©
    --   --   ‚ü¶ tail ‚üß‚ÇÇ (confi c)
    --   -- -- ‚â°‚ü® Eq.sym (mkChoice-preserves tail (confi c)) ‚ü©
    --   --   -- ‚ü¶ mkChoice tail ‚üß‚ÇÇ (confi c)
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ if x then l else tail ‚üß‚ÇÇ (confi c))
    --   --      (Eq.sym (deselect-<n conv c 0<cD)) ‚ü©
    --   --   ‚ü¶ if (confi c) (D ‚àô zero) then l else tail ‚üß‚ÇÇ (confi c)
    --   -- ‚àé
    --   where tail = unroll (suc max) D (r ‚à∑ fromList es)
    --         n    = length es

    --         0<cD : zero < c D
    --         0<cD rewrite cD‚â°i = s‚â§s z‚â§n

    --         max‚à∏n‚â°0 : max ‚à∏ n ‚â° 0
    --         max‚à∏n‚â°0 = eq

    --         m‚â§n : max ‚â§ n
    --         m‚â§n = {!!} -- follows from max‚à∏n‚â°0

    --         m‚â°n : max ‚â° n
    --         m‚â°n = {!!} -- from m‚â§n and n‚â§max

    --         [1+m]‚à∏n‚â°1 : suc max ‚à∏ n ‚â° 1
    --         [1+m]‚à∏n‚â°1 rewrite m‚â°n = {!!} -- follows from 1 + x - x = x

    --         lh : i ‚â° suc i ‚à∏ (suc max ‚à∏ n)
    --         lh rewrite [1+m]‚à∏n‚â°1 = refl

    --         n‚â§1+m : n ‚â§ suc max
    --         n‚â§1+m rewrite m‚â°n = {!!} -- follows from x ‚â§ 1 + x

    --         1+m‚â§1+i+n : suc max ‚â§ suc (i + n)
    --         1+m‚â§1+i+n rewrite m‚â°n = s‚â§s {!!} -- follows from x ‚â§ y + x
    -- ... | suc d = ? -- maybe split on i here?
    --   -- begin
    --   --   ‚ü¶ find-or-last (i ‚à∏ d) (l ‚à∑ r ‚à∑ es) ‚üß‚Çô c
    --   -- ‚â°‚ü® {!!} ‚ü©
    --   --   ‚ü¶ if (confi c) (D ‚àô suc d) then l else tail ‚üß‚ÇÇ (confi c)
    --   -- ‚àé
    --   where tail = unroll (suc max) D (r ‚à∑ fromList es)
    --         n    = length es

    --         m‚à∏n‚â°1+d : max ‚à∏ n ‚â° suc d
    --         m‚à∏n‚â°1+d = eq

    --         n<m : n < max
    --         n<m = {!!} -- follows from m‚à∏n‚â°1+d

    --         m‚à∏n‚â§i : max ‚à∏ n ‚â§ i
    --         m‚à∏n‚â§i = {!!} -- I think, we cannot prove this.

    --         0<m‚à∏n : 0 < max ‚à∏ n
    --         0<m‚à∏n = {!!} -- follows from m‚à∏n‚â°1+d

    --         1+d<cD : suc d < c D
    --         1+d<cD rewrite cD‚â°i | Eq.sym m‚à∏n‚â°1+d = s‚â§s m‚à∏n‚â§i
    --   -- begin
    --   --   -- Choice-Semantics VL‚ÇÅ (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©) c
    --   -- -- ‚â°‚ü®‚ü©
    --   --   -- ‚ü¶ find-or-last (c D) (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- -- ‚â°‚ü® Eq.cong
    --   --      -- (Œª x ‚Üí ‚ü¶ find-or-last x (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c)
    --   --      -- cD‚â°i ‚ü©
    --   --   ‚ü¶ find-or-last (suc i ‚à∏ (max ‚à∏ n)) (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- -- ‚â°‚ü®‚ü©
    --   --   -- ‚ü¶ find-or-last i (r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- ‚â°‚ü® {!!} ‚ü© -- {!convert-preserves-l r es c conv (r‚â°tr ‚à∑ hypot-es) max ? (suc i) cD‚â°i!} ‚ü©
    --   -- --   BinaryChoice-Semantics VL‚ÇÇ (unroll max D (r ‚à∑ fromList es)) (confi c)
    --   -- -- ‚â°‚ü®‚ü©
    --   -- --   BinaryChoice-Semantics VL‚ÇÇ tail (confi c)
    --   -- -- ‚â°‚ü® Eq.sym (mkChoice-preserves tail (confi c)) ‚ü©
    --   --   ‚ü¶ mkChoice tail ‚üß‚ÇÇ (confi c)
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice tail ‚üß‚ÇÇ (confi c))
    --   --      (Eq.sym (deselect-<n conv c {!!})) ‚ü©
    --   --   ‚ü¶ if (confi c) (D ‚àô (max ‚à∏ n)) then t l else mkChoice tail ‚üß‚ÇÇ (confi c)
    --   -- ‚àé
    --   -- where n = length es
    --   --       tail = unroll (suc max) D (r ‚à∑ fromList es)
    --   -- begin
    --   --   ‚ü¶ find-or-last (zero ‚à∏ (max ‚à∏ n)) (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ find-or-last x (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c)
    --   --      (0‚à∏n‚â°0 (max ‚à∏ n)) ‚ü©
    --   --   ‚ü¶ l ‚üß‚ÇÅ c
    --   -- ‚â°‚ü® l‚â°tl ‚ü©
    --   --   ‚ü¶ t l ‚üß‚ÇÇ (confi c)
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ if x then t l else tail ‚üß‚ÇÇ (confi c))
    --   --      (Eq.sym (select-n conv c max‚à∏n‚â°cD)) ‚ü©
    --   --   ‚ü¶ if (confi c) (D ‚àô (max ‚à∏ n)) then t l else tail ‚üß‚ÇÇ (confi c)
    --   -- ‚àé
    --   -- where n = suc (length es)
    --   --       tail = mkChoice (unroll max D (r ‚à∑ fromList es))

    --   --       max‚à∏n‚â°0 : max ‚à∏ n ‚â° 0
    --   --       max‚à∏n‚â°0 = m‚â§n‚áím‚à∏n‚â°0 max‚â§n

    --   --       max‚à∏n‚â°cD : max ‚à∏ n ‚â° c D
    --   --       max‚à∏n‚â°cD = Eq.trans max‚à∏n‚â°0 (Eq.sym cD‚â°i)
    --   --       -- pick : suc n ‚à∏ c D ‚â° suc n
    --   --       -- pick rewrite cD‚â°i = refl
    -- -- convert-preserves-l-step l r es c conv (l‚â°tl ‚à∑ r‚â°tr ‚à∑ es‚â°tes) zero (suc i) n‚â§max z‚â§n cD‚â°i =
    -- --   begin
    -- --     ‚ü¶ find-or-last i (r ‚à∑ es) ‚üß‚ÇÅ c
    -- --   ‚â°‚ü® {!!} ‚ü©
    -- --   -- ‚â°‚ü® convert-preserves-l r es c conv (r‚â°tr ‚à∑ hypot-es) max (suc i) asd cD‚â°i ‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (unroll zero D (r ‚à∑ fromList es)) (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ tail (confi c)
    -- --   ‚â°‚ü® Eq.sym (mkChoice-preserves tail (confi c)) ‚ü©
    -- --     ‚ü¶ mkChoice tail ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü® Eq.cong
    -- --        (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice tail ‚üß‚ÇÇ (confi c))
    -- --        (Eq.sym (deselect-<n conv c {! doable!})) ‚ü©
    -- --     ‚ü¶ if (confi c) (D ‚àô zero) then t l else mkChoice tail ‚üß‚ÇÇ (confi c)
    -- --   ‚àé
    -- --   where tail = unroll zero D (r ‚à∑ fromList es)
    -- -- convert-preserves-l-step l r es c conv (l‚â°tl ‚à∑ r‚â°tr ‚à∑ es‚â°tes) (suc max) (suc i) max‚à∏n‚â§i cD‚â°i = {!!}
    -- -- convert-preserves-l-step l r es c conv (l‚â°tl ‚à∑ r‚â°tr ‚à∑ hypot-es) max (suc i) max‚â§1+i+n cD‚â°i with max ‚à∏ length (r ‚à∑ es) in eq
    -- -- ... | zero =
    -- --   begin
    -- --     ‚ü¶ find-or-last i (r ‚à∑ es) ‚üß‚ÇÅ c
    -- --   ‚â°‚ü® {!!} ‚ü©
    -- --     ‚ü¶ find-or-last (suc i ‚à∏ (max ‚à∏ length es)) (r ‚à∑ es) ‚üß‚ÇÅ c
    -- --   ‚â°‚ü® convert-preserves-l r es c conv (r‚â°tr ‚à∑ hypot-es) max (suc i) asd cD‚â°i ‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (unroll max D (r ‚à∑ fromList es)) (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ tail (confi c)
    -- --   ‚â°‚ü® Eq.sym (mkChoice-preserves tail (confi c)) ‚ü©
    -- --     ‚ü¶ mkChoice tail ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü® Eq.cong
    -- --        (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice tail ‚üß‚ÇÇ (confi c))
    -- --        (Eq.sym (deselect-<n conv c {! doable!})) ‚ü©
    -- --     ‚ü¶ if (confi c) (D ‚àô zero) then t l else mkChoice tail ‚üß‚ÇÇ (confi c)
    -- --   ‚àé
    -- --   where tail = unroll max D (r ‚à∑ fromList es)
    -- --         asd : max ‚à∏ length es ‚â§ suc i
    -- --         asd = {!!}

    -- -- ... | suc x = {!!}
    --   -- begin
    --   --   -- Choice-Semantics VL‚ÇÅ (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©) c
    --   -- -- ‚â°‚ü®‚ü©
    --   --   -- ‚ü¶ find-or-last (c D) (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- -- ‚â°‚ü® Eq.cong
    --   --      -- (Œª x ‚Üí ‚ü¶ find-or-last x (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c)
    --   --      -- cD‚â°i ‚ü©
    --   --   ‚ü¶ find-or-last ((suc i) ‚à∏ (max ‚à∏ n)) (l ‚à∑ r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- -- ‚â°‚ü®‚ü©
    --   --   -- ‚ü¶ find-or-last i (r ‚à∑ es) ‚üß‚ÇÅ c
    --   -- ‚â°‚ü® {!!} ‚ü© -- {!convert-preserves-l r es c conv (r‚â°tr ‚à∑ hypot-es) max ? (suc i) cD‚â°i!} ‚ü©
    --   --   BinaryChoice-Semantics VL‚ÇÇ (unroll max D (r ‚à∑ fromList es)) (confi c)
    --   -- ‚â°‚ü®‚ü©
    --   --   BinaryChoice-Semantics VL‚ÇÇ tail (confi c)
    --   -- ‚â°‚ü® Eq.sym (mkChoice-preserves tail (confi c)) ‚ü©
    --   --   ‚ü¶ mkChoice tail ‚üß‚ÇÇ (confi c)
    --   -- ‚â°‚ü® Eq.cong
    --   --      (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice tail ‚üß‚ÇÇ (confi c))
    --   --      (Eq.sym (deselect-<n conv c {!!})) ‚ü©
    --   --   ‚ü¶ if (confi c) (D ‚àô (max ‚à∏ n)) then t l else mkChoice tail ‚üß‚ÇÇ (confi c)
    --   -- ‚àé
    --   -- where n = length (r ‚à∑ es)
    --   --       tail = unroll max D (r ‚à∑ fromList es)

    --   --       -- TODO: Move to aux proofs
    --   --       asdf : ‚àÄ {n m} ‚Üí suc (n ‚à∏ m) ‚â§ suc n
    --   --       asdf {zero} {zero} = s‚â§s z‚â§n
    --   --       asdf {zero} {suc _} = s‚â§s z‚â§n
    --   --       asdf {suc n} {zero} = ‚â§-refl
    --   --       asdf {suc n} {suc m} = s‚â§s (m‚à∏n‚â§m (suc n) (suc m))

    --         -- pick : max ‚à∏ n < c D
    --         -- pick rewrite cD‚â°i = s‚â§s {!!}

    -- convert-preserves-l e [] c _ max _ _ _ _ = convert-preserves-l-base' e c max
    -- convert-preserves-l l (r ‚à∑ es) c conv max i asd eq cD‚â°i = convert-preserves-l-step l r es c conv max i asd eq cD‚â°i

    -- -- convert-preserves-l :
    -- --     ConfSpec D confi
    -- --   ‚Üí (alts : List‚Å∫ (L‚ÇÅ A))
    -- --   ‚Üí (c : NConfig)
    -- --   ‚Üí All‚Å∫ (Œª e ‚Üí ‚ü¶ e ‚üß‚ÇÅ c ‚â° ‚ü¶ t e ‚üß‚ÇÇ (confi c)) alts
    -- --   ‚Üí   Choice-Semantics       VL‚ÇÅ (D ‚ü® alts ‚ü©) c
    -- --     ‚â° BinaryChoice-Semantics VL‚ÇÇ (unroll D alts zero) (confi c)
    -- -- convert-preserves-l conv (e ‚à∑ []) c (e‚â°tx ‚à∑ []) =
    -- --   begin
    -- --     Choice-Semantics VL‚ÇÅ (D ‚ü® e ‚à∑ [] ‚ü©) c
    -- --   ‚â°‚ü®‚ü©
    -- --     ‚ü¶ e ‚üß‚ÇÅ c
    -- --   ‚â°‚ü® e‚â°tx ‚ü©
    -- --     ‚ü¶ t e ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü® Eq.cong
    -- --        (Œª eq ‚Üí ‚ü¶ eq ‚üß‚ÇÇ (confi c))
    -- --        (Eq.sym
    -- --          (if-idemp ((confi c) (D ‚àô 0)))) ‚ü©
    -- --     ‚ü¶ if ((confi c) (D ‚àô 0)) then (t e) else (t e) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (convert (D ‚ü® e ‚à∑ [] ‚ü©)) (confi c)
    -- --   ‚àé
    -- -- convert-preserves-l conv (l ‚à∑ r ‚à∑ es) c (l‚â°tl ‚à∑ r‚â°tr ‚à∑ hypot-es) with c D in eq
    -- -- ... | zero  =
    -- --   begin
    -- --     ‚ü¶ l ‚üß‚ÇÅ c
    -- --   ‚â°‚ü® l‚â°tl ‚ü©
    -- --     ‚ü¶ t l ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     ‚ü¶ if true then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü® Eq.cong
    -- --        (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c))
    -- --        (Eq.sym (select-n conv c 0 (Eq.sym eq))) ‚ü©
    -- --     ‚ü¶ if (confi c) (D ‚àô 0) then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (convert (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©)) (confi c)
    -- --   ‚àé
    -- -- ... | suc n =
    -- --   begin
    -- --     ‚ü¶ find-or-last n (r ‚à∑ es) ‚üß‚ÇÅ c
    -- --   -- ‚â°‚ü® {!!} ‚ü©
    -- --     -- ‚ü¶ ‚üß‚ÇÇ
    -- --   -- ‚â°‚ü®‚ü©
    -- --     -- BinaryChoice-Semantics VL‚ÇÇ (unroll D (r ‚à∑ es) zero) (confi c)
    -- --   ‚â°‚ü® {!!} ‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (unroll D (r ‚à∑ es) 1) (confi c)
    -- --   ‚â°‚ü® Eq.sym (mkChoice-preserves (unroll D (r ‚à∑ es) 1) (confi c)) ‚ü©
    -- --     ‚ü¶ mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     ‚ü¶ if false then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü® Eq.cong
    -- --        (Œª x ‚Üí ‚ü¶ if x then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c))
    -- --        (Eq.sym (deselect-<n conv c 0 {!!})) ‚ü©
    -- --     ‚ü¶ if (confi c) (D ‚àô 0) then t l else mkChoice (unroll D (r ‚à∑ es) 1) ‚üß‚ÇÇ (confi c)
    -- --   ‚â°‚ü®‚ü©
    -- --     BinaryChoice-Semantics VL‚ÇÇ (convert (D ‚ü® l ‚à∑ r ‚à∑ es ‚ü©)) (confi c)
    -- --   ‚àé

    -- convert-preserves : ‚àÄ (alts : List‚Å∫ Carrier) ‚Üí
    --       ‚ü¶ D ‚ü® alts ‚ü© ‚üß‚Çô
    --     ‚âÖ ‚ü¶ convert (D ‚ü® alts ‚ü©) ‚üß‚ÇÇ
    -- convert-preserves = {!!}
