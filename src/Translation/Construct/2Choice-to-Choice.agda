{-# OPTIONS --allow-unsolved-metas #-}
module Translation.Construct.2Choice-to-Choice {Q : Set} where

open import Data.Bool using (Bool; false; true)
open import Data.List using (List; _‚à∑_; [])
open import Data.List.NonEmpty using (List‚Å∫; _‚à∑_)
open import Data.Nat using (‚Ñï; suc; zero)
open import Data.Product using () renaming (_,_ to _and_)
open import Level using (0‚Ñì)

open import Relation.Binary using (Setoid; IsEquivalence)
open import Relation.Binary.PropositionalEquality as Eq using (_‚â°_; refl)

import Data.IndexedSet

open import Framework.Definitions using (ùîΩ)
open import Framework.Compiler using (ConstructCompiler)
open import Construct.Choices

open 2Choice using (_‚ü®_,_‚ü©)
open Choice using (_‚ü®_‚ü©)

{-|
ConfContract and FnocContract define the requirements we have on translated configurations
to prove preservation of the conversion from binary to n-ary choices.

The requirement for translating binary to n-ary configurations is
that there exist two natural numbers that we can associate with the boolean values true and false.
To simplify things, we fix these two numbers to be 0 for true, and 1 for false. These values are chosen such that
`D < l ,  r       >` lines up with
`D < l :: r :: [] >`
-}
record ConfContract (f : Q) (conf : 2Choice.Config Q ‚Üí Choice.Config Q) : Set where
  field
    false‚Üí1 : ‚àÄ (c : 2Choice.Config Q)
      ‚Üí c f ‚â° false
      ‚Üí (conf c) f ‚â° 1

    true‚Üí0 : ‚àÄ (c : 2Choice.Config Q)
      ‚Üí c f ‚â° true
      ‚Üí (conf c) f ‚â° 0
open ConfContract

{-|
ConfContract and FnocContract define the requirements we have on translated configurations
to prove preservation of the conversion from binary to n-ary choices.

The requirement for translating n-ary to binary configurations is
that we can associate each natural numbers with the boolean values true and false,
such that the association is inverse to ConfContract.
Hence, we associate 0 with true and all other numbers with false.
-}
record FnocContract (f : Q) (fnoc : Choice.Config Q ‚Üí 2Choice.Config Q) : Set where
  field
    suc‚Üífalse : ‚àÄ {n} (c : Choice.Config Q)
      ‚Üí c f ‚â° suc n
      ‚Üí (fnoc c) f ‚â° false

    zero‚Üítrue : ‚àÄ (c : Choice.Config Q)
      ‚Üí c f ‚â° zero
      ‚Üí (fnoc c) f ‚â° true
open FnocContract

default-conf : 2Choice.Config Q ‚Üí Choice.Config Q
default-conf cb f with cb f
... | false = 1
... | true  = 0

default-fnoc : Choice.Config Q ‚Üí 2Choice.Config Q
default-fnoc cn f with cn f
... | zero    = true
... | (suc _) = false

default-conf-satisfies-contract : ‚àÄ (f : Q) ‚Üí ConfContract f default-conf
false‚Üí1 (default-conf-satisfies-contract f) c cf‚â°false rewrite cf‚â°false = refl
true‚Üí0  (default-conf-satisfies-contract f) c cf‚â°true  rewrite cf‚â°true  = refl

default-fnoc-satisfies-contract : ‚àÄ (f : Q) ‚Üí FnocContract f default-fnoc
suc‚Üífalse (default-fnoc-satisfies-contract f) c cf‚â°suc  rewrite cf‚â°suc  = refl
zero‚Üítrue (default-fnoc-satisfies-contract f) c cf‚â°zero rewrite cf‚â°zero = refl

module Translate {‚Ñì} (S : Setoid ‚Ñì ‚Ñì) where
  open Setoid S
  module ‚âà-Eq = IsEquivalence isEquivalence

  -- TODO: This should be put into a ConstructCompiler.
  --       However, that might not be possible because it would require to abstract
  --       arbitrary requirements on the configuration compiler.
  --       Maybe this could be done via type parameters but lets see whether it pays off.
  convert : 2Choice.Syntax Q Carrier ‚Üí Choice.Syntax Q Carrier
  convert (D ‚ü® l , r ‚ü©) = D ‚ü® l ‚à∑ r ‚à∑ [] ‚ü©

  module Preservation
    (conf : 2Choice.Config Q ‚Üí Choice.Config Q)
    (fnoc : Choice.Config Q ‚Üí 2Choice.Config Q)
    (chc : 2Choice.Syntax Q Carrier)
    where
    open Data.IndexedSet S using (_‚äÜ[_]_; _‚âÖ[_][_]_; _‚âÖ_)

    preserves-conf :
        ConfContract (2Choice.Syntax.dim chc) conf
      ‚Üí 2Choice.‚ü¶ chc ‚üß ‚äÜ[ conf ] Choice.‚ü¶ convert chc ‚üß
    preserves-conf conv c with c (2Choice.Syntax.dim chc) in eq
    ... | false rewrite false‚Üí1 conv c eq = ‚âà-Eq.refl
    ... | true  rewrite true‚Üí0  conv c eq = ‚âà-Eq.refl

    preserves-fnoc :
        FnocContract (2Choice.Syntax.dim chc) fnoc
      ‚Üí Choice.‚ü¶ convert chc ‚üß ‚äÜ[ fnoc ] 2Choice.‚ü¶ chc ‚üß
    preserves-fnoc vnoc c with c (2Choice.Syntax.dim chc) in eq
    ... | zero  rewrite zero‚Üítrue vnoc c eq = ‚âà-Eq.refl
    ... | suc _ rewrite suc‚Üífalse vnoc c eq = ‚âà-Eq.refl

    convert-preserves :
        ConfContract (2Choice.Syntax.dim chc) conf
      ‚Üí FnocContract (2Choice.Syntax.dim chc) fnoc
      ‚Üí 2Choice.‚ü¶ chc ‚üß ‚âÖ[ conf ][ fnoc ] Choice.‚ü¶ convert chc ‚üß
    convert-preserves conv vnoc = preserves-conf conv and preserves-fnoc vnoc

  -- compiler : ‚àÄ (F : ùîΩ) ‚Üí ConstructCompiler (C‚ÇÇ F) (C‚Çô F)
  -- compiler F = record
  --   { compile = {!convert!}
  --   ; config-compiler = {!!}
  --   ; stable = {!!}
  --   ; preserves = {!!}
  --   }
